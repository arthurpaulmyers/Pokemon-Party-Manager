# Pokemon Party Manager

Please access the final project at: 

Homework Response:

Part 1)
This website allows users to manage their parties in a playthrough of either Pokemon HeartGold or Pokemon Soul Silver versions using jquery and an open Pokemon API. It is meant to give the most essential information for users to understand their teams: the species of Pokemon, the level the Pokemon is at, and the Pokemon's attacks. Truly, it is not particularly interesting - it was an exercise in using an API (and AJAX) for the first time - but many Pokemon information resources and walkthroughs that exist are full of loads of irrelevant data. Boiling down to the essentials makes for a more readable website and also would theoretically be more useful for blind gamers. The target audience for this application is blind Pokemon gamers who otherwise have to rely upon memory, their own data entry, and large walkthroughs to understand their teams' progress in-games. Inspiration for this website came from reading posts from r/knighthawk321, a blind Pokemon gamer.

Part 2)
Interactions for this website include:
- Adding up to six team members by pressing the "Add Team Member" button. In doing so, a "choose location" form appears, and players select a given location from a dropdown. Upon submitting that result, they can choose from any of the Pokemon obtainable in that location. After selecting that Pokemon, the Pokemon is added to the party. This can be done up to six times. Try adding Cyndaquil as your starter Pokemon, then adding Sentret and Hoothoot as two Pokemon found on Route 29.
- Learning about each team member by pressing the Team Slot buttons. In doing so, the page populates with the Pokemon's image, type, and current level as well as the attacks it knows. Upon being added to the team, it is already a certain level and knows specific moves. This is specific to the particular location in which it was caught. Select between any of your party members to see this in action.
- Adding to the Pokemon's level. On each team members' particular sections, a "Level Up" button exists. By selecting it, the Pokemon gains a level. Upon reaching certain levels, the Pokemon attempts to learn moves - if it knows less than four, it automatically learns it. If it knows more than four, a dialogue pops up asking if it wants to forget a move to make room for the new move. Additionally, upon reaching a certain level, the Pokemon evolves. Choose Cyndaquil, and watch it learn new attacks as it goes from level 5 to level 14 - and then watch it evolve into Quilava.

Part 3)
I used PokeAPI, an open Pokemon Game Data API.
- I used this tool because it contains a huge amount of Pokemon Game Data. I had hoped that I could use the API to generate a list of all locations in a particular Pokemon game, a list of each of the Pokemon obtainable in each of those locations, and then information about all those Pokemon. As it turns out, the API is not as robust as I thought - I could gain information about all Pokemon in the up-to 17 games in which it exists (and then filter it down to the test case of HeartGold or SoulSilver as intended), but the locations and Pokemon-per-location functionality does not exist. As such, I ended up hard-coding much more of the site than I intended, and ultimately, I would have chosen a different final project had I known this at onset due to its lack of scalability.
- I set up the website to make API calls to populate game information on the species' you selected - each call being approximately 250 microsoft word pages of game data. By sorting through this data, I was able to pick out all the most relevant information for the game for which I am designing and then display that information on-screen. The game data I had to manually write out were the locations (which is why there were only two), the Pokemon available in each location, and the level and species of evolution. Everything else comes directly from the API calls.
- Without the API, the website would not be possible - I could generate an entire repository of game data by hand, but that would be majorly time-inefficient and prone to error, as I would be relying upon secondary sources.

I additionally used jQuery and AJAX to populate the page instead of a more robust framework or library.
- I chose to do this because I had never worked with an API before. I do not feel particularly confident with React, and having never worked with an API, I wanted to make sure the code was as vanilla as possible. Additionally, I know ARIA for screen-reader functionality works with AJAX, so I intended to make use of that.
- I realized quickly I had never written such complicated web-development-focused Javascript before, and so much of my website would need to rely upon writing HTML in my Javascript. React likely would have been much cleaner code. Using jQuery and AJAX is pretty straight-forward though: I made sure to add id's to all my content to make for easier replacement.
- This adds interactivity to my website and ensures the page does not get too vertically long. Initial iterations existed only in my console log (as I needed to write out the parsing of the API and make sure it worked before translating it to a web page), but that made it so I did not have a sense of scale when I pushed the content to the HTML file, and that file ended up requiring a lot of scrolling to navigate visually. Adding in the content-changing code made the website easier to navigate.

Finally, I used Bootstrap for very basic responsiveness.
- I don't want to re-invent the wheel. My website is purely functional, and, at its most useful, isn't even visual. That is not an excuse for poor visual design for sighted users, though, and I wanted to make sure the page had good information architecture and layout to support sighted and non-sighted users.
- I used Bootstrap fairly simply: adding classes to my HTML content. I did not expect to have to write so many classes in the scripts page, however, and the nature of writing multi-line HTML within a Javascript file made this frustrating and slow.
- Bootstrap adds a level of responsiveness that makes me comfortable using my program on any sided screen.

Part 4)
Firstly, the box feature listed in HW7 was far more complicated than I originally intended, and while I could set up my code to add an unlimited number of Pokemon with only the first six appearing in the party, trying to get the box model to fit into my one-page execution of my idea simply didn't work. Additionally, I could not figure out the "level verification" functionality I originally intended to create, and as such, the Pokemon that join your party are simply at the lowest level at which you can encounter them in any given location. Finally, I did not include any audio in this project. The current scope was too large, and even if I could include audio, I do not know enough about implementing it in a way that is useful for blind users to make that decision. I did reach out r/blindPokemon, a Reddit Page dedicated to creating walkthroughs for blind Pokemon players, to learn which information was most useful to successfully navigate a playthrough and what types of content would be most accessible... and received no feedback outside of upvotes, so I did not take any risks when it came to functionality.

Part 5)
- Firstly, the PokeAPI is out-of-date, with documentation spanning both its original version and its very changed second version, and with no Cross-Resource Origin Sharing header - so until I found a workaround for that, I couldn't even start this project.
- Secondly, having never worked with an API before, I made assumptions about what it contained and what I would be able to do without actually understanding the data fully. The API was simultaneously far less robust and far more complex than I originally thought, making it so I spent a great deal of time simply trying to get the data I wanted to test whether my code worked instead of actually coding a web page.
- Finally, despite starting tutorials for working with APIs and planning for this project as soon as the assignment was available, I did not anticipate it being such a difficult project for me, and I let the development seep into final projects week when I had intended to finish it beforehand. With other projects being group projects and having earlier deadlines, development on this mostly halted for the week of December 1st, and that led to a rushed final product.

Afterward)
I learned so much while working on this project, but the end result is not something particularly sophisticated. Truly, had I realized how little I could do with the PokeAPI before November 20th, I would have chosen a different project.